#!/usr/bin/env bash
# gw - A Terminal User Interface wrapper to make Git worktrees easier to manage

#set -eu
[ "${DEBUG:-0}" = "1" ] && set -x

# NOTE:
# We intentionally do NOT set -e here because dialog-driven control flow relies
# on inspecting exit codes (e.g. cancel vs OK). We add pipefail for safer pipes.
set -o pipefail

declare -a worktree_list gw_commandlist
# worktree_list stores pairs: path branch path branch ... (Bash 3.x friendly)

DIALOG_ERROR=-1 DIALOG_OK=0 DIALOG_CANCEL=1 DIALOG_HELP=2
DIALOG_ITEM_HELP=2 DIALOG_EXTRA=3 DIALOG_TIMEOUT=5 DIALOG_ESC=255
# Dialog exit/status codes reference (only DIALOG_OK currently used in logic):
#   DIALOG_OK=0          User accepted (e.g. chose menu item / answered Yes)
#   DIALOG_CANCEL=1      User pressed Cancel
#   DIALOG_HELP=2        Help button (not wired here)
#   DIALOG_ITEM_HELP=2   (Alias) Item help code
#   DIALOG_EXTRA=3       Extra button (unused)
#   DIALOG_TIMEOUT=5     Timed out (unused)
#   DIALOG_ESC=255       ESC pressed (unused)
# Keeping them: clarifies potential future branching without scattering magic numbers.

SCRIPT="$(basename "$0")"

gw_commandlist=(switch add convert remove list)

_die () { _err "$*" ; exit 1 ; }
_err () { printf "%s: Error: %s\n" "$SCRIPT" "$*" ; }
_debug () { printf "%s: Debug: %s\n" "$SCRIPT" "$*" 1>&2 ; }
_errifnot () { if [ $1 -ne $2 ] ; then _debug "Error: return status $1" ; return 1 ; fi ; return 0 ; }

_get_worktree_list () {
    local wt='' branch=''
    while read -r -a entry ; do
        if [ "${entry[0]}" = "worktree" ] ; then
            wt="${entry[1]}"
        elif [ "${entry[0]}" = "branch" ] ; then
            branch="${entry[1]##refs/heads/}"
        elif [ -z "${entry[0]}" ] ; then
            worktree_list+=("$wt" "$branch")
            wt='' branch=''
        fi
    done < <(git worktree list --porcelain)
}

## Removed unused helpers (_map_entries, _set_default_vars, _parse_git_remote_repo,
## _set_repo_vars, _gw_clone) to keep file lean. Reintroduce if future features need them.

_gw_switch () {
    local prefix prefixdir
    prefix="$(git rev-parse --show-prefix)"
    local execlist worktree_list c tmpfile result current prompttxt
    local branchname
    branchname="$(git rev-parse --abbrev-ref HEAD)"
    prompttxt="$(printf "%s\n" "Select a worktree branch to change current directory to." "" "Current branch is indicated with an asterisk.")"
    execlist=(dialog --title "Worktree switch" --menu "$prompttxt" 0 0 0 -1 "(DEFAULT)")
    _get_worktree_list
    c=0; while [ $c -lt ${#worktree_list[@]} ] ; do
        current="${worktree_list[$((c+1))]}"
        if [ "$branchname" = "$current" ] ; then
            current="* $current"
        else
            current="  $current"
        fi
        execlist+=("$c" "$current")
        c=$((c+2))
    done
    tmpfile="$(mktemp)"
    "${execlist[@]}" 2>"$tmpfile"
    _errifnot $? $DIALOG_OK || return 1
    result="$(cat "$tmpfile")"
    rm -f "$tmpfile"
    [ "$result" = "-1" ] && return
    if [ -d "${worktree_list[$result]}" ] ; then
        echo "+ cd '${worktree_list[$result]}'"
        prefixdir="${old_worktree_prefix:-$prefix}"
        if [ ! -d "${worktree_list[$result]}/$prefixdir" ] ; then
            _debug "Could not find '$prefixdir' in worktree dir '${worktree_list[$result]}'; going to git root instead"
            old_worktree_prefix="$prefixdir"
            cd "${worktree_list[$result]}" || _debug "Could not cd to '${worktree_list[$result]}'"
        else
            unset old_worktree_prefix
            cd "${worktree_list[$result]}/$prefixdir" || _debug "Could not cd to '${worktree_list[$result]}/$prefixdir'"
        fi
    else
        _debug "No such directory '${worktree_list[$result]}'"
    fi
}

_gw_add () {
    local gitroot branchname
    gitroot="$(git rev-parse --show-toplevel)" || return 1
    branchname="$(git rev-parse --abbrev-ref HEAD)" || return 1
    local execlist result=() path args formdesc
    formdesc="$(printf "%s\n" \
        "Specify the following to add a new git worktree:" \
        "  1) 'Create new branch?' - put 'y' to create a new branch, and fill out the 'New branch' section." \
        "  2) 'Origin branch' - If not creating a new branch, this is the branch to use. If creating a new branch, this is the origin branch used to start a new branch." \
        "  3) 'New branch' - The new branch name, if created.")"
    execlist=(dialog --title "Add a new worktree" --form "$formdesc" 0 0 0 \
            "Create new branch (y/n)" 1 1 "y" 1 25 30 0 \
            "Origin branch" 2 1 "$branchname" 2 25 99 0 \
            "New branch" 3 1 "" 3 25 99 0)
    tmpfile="$(mktemp)"
    "${execlist[@]}" 2>"$tmpfile"
    _errifnot $? $DIALOG_OK || return 1
    IFS=$'\n' read -r -d '' -a result <"$tmpfile"
    rm -f "$tmpfile"
    if [ -z "${result[1]}" ] ; then
        _debug "No origin branch name" ; return 1
    fi
    args=(git worktree add)
    if [ "${result[0]:-}" = "y" ] || [ "${result[0]:-}" = "Y" ] ; then
        if [ -z "${result[2]}" ] ; then
            _debug "No new branch name" ; return 1
        fi
        path="$(dirname "$gitroot")/${result[2]}"
        args+=("-b" "${result[2]}" "$path" "${result[1]}")
    else
        path="$(dirname "$gitroot")/${result[1]}"
        args+=("$path" "${result[1]}")
    fi
    echo "+ ${args[*]}"
    if "${args[@]}" ; then
        echo "+ cd '$path'"
        cd "$path" || return
    fi
}

_gw_convert () {
    local execlist=() gitroot branchname newdir prompttxt dest dest_parent top_component
    gitroot="$(git rev-parse --show-toplevel)" || return 1
    branchname="$(git rev-parse --abbrev-ref HEAD)" || return 1
    dest="$gitroot/$branchname"
    dest_parent="$(dirname "$dest")"
    top_component="${branchname%%/*}"
    if [ -e "$(dirname "$gitroot")/.gwrc" ] ; then
        _debug "Parent is already a gw directory; conversion likely unnecessary"
        return 1
    fi
    if [ -e "$dest" ] ; then
        _debug "Destination '$dest' already exists; aborting convert"
        return 1
    fi
    prompttxt="$( printf "%s\n" \
        "Repository: $gitroot" \
        "Remote:" "$(git remote -v)" \
        "" \
        "Will create branch directory: $dest" \
        "'convert' copies ALL files (tracked, untracked, ignored) including .git into a new directory," \
        "then removes originals from the parent, leaving only branch directories + .gwrc." \
        "" \
        "Continue?" )"
    execlist=(dialog --title "Convert this repository to a worktree subdirectory" --yesno "$prompttxt" 0 0)
    "${execlist[@]}"
    _errifnot $? $DIALOG_OK || return 1
    newdir="$(mktemp -d)" || { _debug "Failed to allocate temp dir"; return 1; }
    # Copy phase: include hidden and regular entries (except . and ..). Use dotglob/nullglob safely.
    (
        shopt -s dotglob nullglob
        local items=(*)
        if [ ${#items[@]} -eq 0 ] ; then
            _debug "Nothing to copy? (Empty directory)"; exit 1
        fi
        cp -a "${items[@]}" "$newdir/" || exit 1
    ) || { _debug "Copy phase failed"; return 1; }
    # Create destination parent path (supports branch names with slashes)
    mkdir -p "$dest_parent" || { _debug "Failed to create parent '$dest_parent'"; return 1; }
    # Move the copied snapshot into its final branch directory
    if ! mv "$newdir" "$dest" ; then
        _debug "Move of '$newdir' to '$dest' failed"
        return 1
    fi
    # Write/overwrite .gwrc at parent to mark origin workdir
    echo "ORIGIN_WORKDIR=\"$dest\"" > .gwrc || _debug "Failed writing .gwrc"
    # Remove original items from root EXCEPT the branch top component (and .gwrc we just wrote)
    (
        shopt -s dotglob nullglob
        for f in *; do
            [ "$f" = "$top_component" ] && continue
            [ "$f" = ".gwrc" ] && continue
            rm -rf -- "$f"
        done
    )
    cd "$branchname" || _debug "Converted but failed to cd into branch dir '$branchname'"
}

_gw_remove () {
    local execlist=() gitroot branchname prompttxt curworkdir newworkdir
    gitroot="$(git rev-parse --show-toplevel)" || return 1
    branchname="$(git rev-parse --abbrev-ref HEAD)" || return 1
    prompttxt="$( printf "%s\n" \
        "Repository: $gitroot" \
        "Remote:" "$(git remote -v)" \
        "" \
        "Remove worktree '$branchname' ?" )"
    _get_worktree_list
    # Walk pair array once: record current worktree path and the first alternative.
    local i path branch
    for ((i=0; i<${#worktree_list[@]}; i+=2)); do
        path="${worktree_list[i]}"; branch="${worktree_list[i+1]}"
        if [ "$branch" = "$branchname" ]; then
            curworkdir="$path"
        elif [ -z "${newworkdir:-}" ]; then
            newworkdir="$path"
        fi
    done
    if [ -z "${curworkdir:-}" ]; then _debug "Current worktree path not found"; return 1; fi
    if [ -z "${newworkdir:-}" ]; then _debug "No alternate worktree to switch into before removal"; return 1; fi
    execlist=(dialog --title "Remove worktree" --yesno "$prompttxt" 0 0)
    "${execlist[@]}"
    _errifnot $? $DIALOG_OK || return 1
    cd "$newworkdir" || { _debug "Failed to cd to '$newworkdir'"; return 1; }
    git worktree remove "$curworkdir"
}

_gw_list () {
    dialog --title "Worktree list" --msgbox "$(git worktree list -v)" -1 -1
}

_gw () {
    local execlist=() c=0 result prompttxt gitroot
    gitroot="$(git rev-parse --show-toplevel)"
    prompttxt="$(printf "%s\n" "Repository: $gitroot" "" "Select a wrapper command")"
    execlist=(dialog --title "Git Worktree wrapper" --menu "$prompttxt" 0 0 0 -1 "(NONE)")
    for cmd in "${gw_commandlist[@]}" ; do
        execlist+=("$c" "$cmd")
        c=$((c+1))
    done
    tmpfile="$(mktemp)"
    "${execlist[@]}" 2>"$tmpfile"
    _errifnot $? $DIALOG_OK || return 1
    result="$(cat "$tmpfile")"
    rm -f "$tmpfile"
    [ "$result" = "-1" ] && return
    _gw_runcmd "${gw_commandlist[$result]}"
}

_gw_runcmd () {
    case "$1" in
        -h|--help)  _gw_usage ;;
        sw|switch)  _gw_switch ;;
        a|add)      _gw_add ;;
        convert)    _gw_convert ;;
        remove)     _gw_remove ;;
        list)       _gw_list ;;
        *)          _debug "Invalid command: '$1'" ;;
    esac
}

_check_deps () {
    for cmd in git dialog ; do
        command -v "$cmd" >/dev/null || _die "Could not find command: $cmd"
    done
}

_gw_usage () {
    cat <<EOUSAGE
gw: Wrapper around 'git worktree'

Usage: $SCRIPT [COMMAND]

1. Keep a directory 'foo', and in that directory clone a Git repository, with the
   name of your main branch (so, 'foo/main').
2. Change to that directory and run '. gw' (if 'gw' is in your path, this will find
   'gw' and load it into your shell, which will enable it to change the current
   directory of your shell).
3. You can then select a command to run and the wrapper will make it easier to use.

Commands:

    switch          Switch to a worktree directory. Looks up your worktree list,
                    presents you with a list of branches, and when you select one,
                    your current shell will change to the directory of that worktree.

    add             Add a new worktree directory. Put in the name of the source branch
                    and the name of a new branch, and a new worktree will be created
                    with the new branch name (ex. 'foo/new-branch').

    convert         Convert a git repository into a worktree-compatible form. Basically
                    it just makes a new temp directory, copies all the files in the current
                    directory there, removes all the files in the current directory, and
                    then moves the temp directory into the current one with the name of the
                    branch that was previously checked out. From here you can run workdir
                    commands and they will create directories in a parent directory
                    (using the name of the branch you want a worktree for).

    list            List the current worktrees.
EOUSAGE
    return 1
}

## (Removed obsolete commented testing lines.)

_check_deps

if [ -r .gwrc ] ; then
    origin_workdir="$(env -i sh -c 'set -a; . ./.gwrc ; echo $ORIGIN_WORKDIR')"
    _debug "Found .gwrc; moving to origin worktree '$origin_workdir'"
    cd "$origin_workdir" || _debug "Failed to cd to origin worktree '$origin_workdir'"
fi

if ! git rev-parse 2>/dev/null ; then _debug "Current directory is not a Git work tree" ; return 1 ; fi

if [ $# -lt 1 ] ; then
    _gw
else
    _gw_runcmd "$@"
fi
